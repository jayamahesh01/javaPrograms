public class TowerOfHanoi {
    
    // Recursive function to solve Tower of Hanoi puzzle
    public static void solveHanoi(int n, char fromRod, char toRod, char auxRod) {
        // Base case: If only one disk, move it from source to destination
        if (n == 1) {
            System.out.println("Move disk 1 from rod " + fromRod + " to rod " + toRod);
            return;
        }
        
        // Recursive case: Move top n-1 disks from source to auxiliary rod
        solveHanoi(n - 1, fromRod, auxRod, toRod);
        
        // Move the nth disk from source to destination rod
        System.out.println("Move disk " + n + " from rod " + fromRod + " to rod " + toRod);
        
        // Move the n-1 disks from auxiliary rod to destination rod
        solveHanoi(n - 1, auxRod, toRod, fromRod);
    }
    
    public static void main(String[] args) {
        int n = 3; // Number of disks
        solveHanoi(n, 'A', 'C', 'B'); // Names of rods: A is source, C is destination, B is auxiliary
    }
}

------------------------------------------------------------------------------------------------------------------------------


public class TowerOfHanoi {

    public static void solveHanoi(int n, char source, char auxiliary, char destination) {
        if (n == 1) {
            System.out.println("Move disk 1 from " + source + " to " + destination);
            return;
        }

        solveHanoi(n - 1, source, destination, auxiliary);
        System.out.println("Move disk " + n + " from " + source + " to " + destination);
        solveHanoi(n - 1, auxiliary, source, destination);
    }

    public static void main(String[] args) {
        int n = 3;
        solveHanoi(n, 'A', 'B', 'C');
    }
}
--------------------------------------------------------------------------------------------------------------------------------

task 2:

public class TravelingSalesmanProblem {

    public static int findMinCost(int[][] graph) {
        int n = graph.length;
        int[][] dp = new int[1 << n][n];

        for (int[] row : dp) {
            Arrays.fill(row, Integer.MAX_VALUE / 2); // Initialize with a large value to avoid overflow
        }

        dp[1][0] = 0; // Starting city is 0

        for (int mask = 1; mask < (1 << n); mask += 2) {
            for (int i = 1; i < n; i++) {
                if ((mask & (1 << i)) != 0) {
                    for (int j = 0; j < n; j++) {
                        if ((mask & (1 << j)) != 0) {
                            dp[mask][i] = Math.min(dp[mask][i], dp[mask ^ (1 << i)][j] + graph[j][i]);
                        }
                    }
                }
            }
        }

        int minCost = Integer.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            minCost = Math.min(minCost, dp[(1 << n) - 1][i] + graph[i][0]);
        }

        return minCost;
    }

    public static void main(String[] args) {
        int[][] graph = {
            {0, 10, 15, 20},
            {10, 0, 35, 25},
            {15, 35, 0, 30},
            {20, 25, 30, 0}
        };
        System.out.println("Minimum cost to visit all cities: " + findMinCost(graph));
    }
}



--------------------------------------------------------------------------------------------------------------------------


implementation:   

com.computationalalgorithms;
 
public class TravelingSalesman {
	 // Function to solve the TSP using Dynamic Programming
    public static int tsp(int[][] dist) {
        int n = dist.length;
        int VISITED_ALL = (1 << n) - 1;
        int[][] dp = new int[1 << n][n];
 
        // Initialize dp array with a large value
        for (int i = 0; i < (1 << n); i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
 
        // Base case: starting from the first city
        dp[1][0] = 0;
 
        // Iterate over all subsets of cities
        for (int mask = 1; mask < (1 << n); mask++) {
            for (int i = 0; i < n; i++) {
                // Continue if the ith city is not in the subset represented by mask
                if ((mask & (1 << i)) == 0) continue;
 
                // Try to find the minimum cost path to city i
                for (int j = 0; j < n; j++) {
                    if ((mask & (1 << j)) != 0 && i != j) {
                        dp[mask][i] = Math.min(dp[mask][i], dp[mask ^ (1 << i)][j] + dist[j][i]);
                    }
                }
            }
        }
 
        // Find the minimum cost to visit all cities and return to the starting city
        int minCost = Integer.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            minCost = Math.min(minCost, dp[VISITED_ALL][i] + dist[i][0]);
        }
 
        return minCost;
    }
 
    public static void main(String[] args) {
        int[][] dist = {
            {0, 10, 15, 20},
            {10, 0, 35, 25},
            {15, 35, 0, 30},
            {20, 25, 30, 0}
        };
 
        System.out.println("The minimum cost is " + tsp(dist));
    }
}


--------------------------------------------------------------------------------------------------------------------------------------

task 3:

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Job {
    int Id, Deadline, Profit;

    public Job(int Id, int Deadline, int Profit) {
        this.Id = Id;
        this.Deadline = Deadline;
        this.Profit = Profit;
    }
}

public class JobSequencing {
    
    public static List<Job> JobSequencing(List<Job> jobs) {
        // Step 1: Sort jobs by profit in descending order
        Collections.sort(jobs, (a, b) -> b.Profit - a.Profit);
        
        // Step 2: Find the maximum deadline
        int maxDeadline = 0;
        for (Job job : jobs) {
            if (job.Deadline > maxDeadline) {
                maxDeadline = job.Deadline;
            }
        }
        
        // Step 3: Create a schedule array to keep track of free time slots
        int[] schedule = new int[maxDeadline];
        for (int i = 0; i < maxDeadline; i++) {
            schedule[i] = -1;
        }
        
        // Step 4: Schedule jobs
        List<Job> result = new ArrayList<>();
        for (Job job : jobs) {
            // Find a time slot from job.Deadline to 1
            for (int j = job.Deadline - 1; j >= 0; j--) {
                if (schedule[j] == -1) {
                    schedule[j] = job.Id;
                    result.add(job);
                    break;
                }
            }
        }
        
        return result;
    }

    public static void main(String[] args) {
        List<Job> jobs = new ArrayList<>();
        jobs.add(new Job(1, 2, 100));
        jobs.add(new Job(2, 1, 19));
        jobs.add(new Job(3, 2, 27));
        jobs.add(new Job(4, 1, 25));
        jobs.add(new Job(5, 3, 15));

        List<Job> result = JobSequencing(jobs);
        System.out.println("Scheduled jobs for maximum profit:");
        for (Job job : result) {
            System.out.println("Job Id: " + job.Id + ", Deadline: " + job.Deadline + ", Profit: " + job.Profit);
        }
    }
}

------------------------------------------------------------------------------------------------------------------------------
implementation:

import java.util.Arrays;
 
class Job {
    char id;     // Job Id
    int deadline; // Deadline of job
    int profit;  // Profit if job is completed before or on deadline
    
    // Constructor
    public Job(char id, int deadline, int profit) {
        this.id = id;
        this.deadline = deadline;
        this.profit = profit;
    }
}
 
public class JobSequencing {
 
    // Function to schedule the jobs to maximize profit
    public static void scheduleJobs(Job[] jobs, int n) {
        // Sort jobs in descending order of profit
        Arrays.sort(jobs, (a, b) -> b.profit - a.profit);
        
        // To keep track of free time slots
        boolean[] result = new boolean[n];
        
        // To store the sequence of jobs
        char[] jobOrder = new char[n];
        
        // Initialize all slots to be free
        for (int i = 0; i < n; i++) {
            result[i] = false;
        }
        
        // Iterate through all given jobs
        for (int i = 0; i < jobs.length; i++) {
            // Find a free slot for this job (starting from the last possible slot)
            for (int j = Math.min(n, jobs[i].deadline) - 1; j >= 0; j--) {
                // Free slot found
                if (result[j] == false) {
                    result[j] = true;
                    jobOrder[j] = jobs[i].id;
                    break;
                }
            }
        }
        
        // Print the job order to maximize profit
        System.out.println("Job sequence to maximize profit:");
        for (int i = 0; i < n; i++) {
            if (result[i]) {
                System.out.print(jobOrder[i] + " ");
            }
        }
        System.out.println();
    }
 
    // Driver code
    public static void main(String[] args) {
        Job[] jobs = {
            new Job('a', 2, 100),
            new Job('b', 1, 19),
            new Job('c', 2, 27),
            new Job('d', 1, 25),
            new Job('e', 3, 15)
        };
        int n = 3;  // Number of time slots
        scheduleJobs(jobs, n);
    }
}
-----------------------------------------------------------------------------------------------------------------------------

public class Knapsack {
    
    public static int knapsack(int W, int[] weights, int[] values) {
        int n = weights.length;
        int[][] dp = new int[n + 1][W + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int w = 0; w <= W; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        
        return dp[n][W];
    }
    
    public static void main(String[] args) {
        int W = 50;
        int[] weights = {10, 20, 30};
        int[] values = {60, 100, 120};
        
        System.out.println(knapsack(W, weights, values));  // Output: 220
    }
}

.....................................................................................................................................................
Task 2: Longest Common Subsequence (LCS)

The Longest Common Subsequence problem can also be solved using dynamic programming. Here is the Java implementation for finding the length of the LCS:


public class LCS {
    
    public static int lcs(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        // Build the dp array in bottom-up manner
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    public static void main(String[] args) {
        String text1 = "abcde";
        String text2 = "ace";
        
        System.out.println(lcs(text1, text2));  // Output: 3
    }
}

-------------------------------------------------------------------------------------------------------------------------------

knapsackmycode:

import java.util.Arrays;
public class FractionalKnapsack {
	static int temp,temp1;
	
	
	public static int  fractionalKnapsack(int weight[],int values[], int maxWeight,int n)
	{
		
	      int low=0,high=values.length-1;
		
		   quickSort(values,low,high,weight);
		     
		   int compare=0,sum=0;
		   
		compare=0;
		   
		   for(int i=n;i>=0;i--)
		   {
			  //compare=compare+weight[i];
          
           if(compare<=maxWeight)
           {
        	   if(i!=n)
        	   {
        		   
        	   
        	   sum=sum+values[i];
        	  
                
           
        	   }
        	   if(i==n)
        		   
        	   {
        		   compare=compare+weight[n-1];
        	   }
        	   else {
        		   compare=compare+weight[i-1];
        	   }
        	  // compare=compare+weight[i];
           }
           
           else {
        	   if(i!=0)
        	   {
        	     
        	   compare=compare-weight[i];
        	   compare=compare+weight[i-1];
        	   
        	   }
        	   
        	 }
			   
		   
		   }
		     return sum;
	}
	
	public static void quickSort(int values[],int low,int high,int weight[])
	{
		
		if(low>=high)
		{
			return;
		}
		int mid=low+(high-low)/2;
		int pivot=values[mid];
		int i=low;
		int j=high;
		while(i<=j)
		{
			while(values[i]<pivot)
			{
				i++;
			}
			
			
			
			while(values[j]>pivot)
			{
				j--;
			}
			
	       if(i<=j)
	       {
	    	   temp=values[i];
	    	   temp1=weight[i];
	    	   values[i]=values[j];
	    	   weight[i]=weight[j];
	    	   values[j]=temp;
	    	   weight[j]=temp1;
	    	   
	    	   i++;
	    	   j--;
	    	   
	       }
	       
	       
	       
		}
		
		quickSort(values,low,j,weight);
		quickSort(values,i,high,weight);
		
}
	
	
	public static void main(String args[])
	
{
      int weight[]=	{1,4,2,6,5,8};
      int values[]= {400,254,978,121,542,70};
      int maxWeight=20;
      int n=weight.length;
      
       System.out.println("MaxValue of maxCapacity of knapsack: "+fractionalKnapsack(weight,values,maxWeight,n));
		
}
---------------------------------------------------------------------------------------------------
LCS implementation:

class LCS{
    

public static void lcs(String a , String compare)
{
    int i=0,j=0,count=0,x=0,k=0,h=0;
    int n=compare.length()-1,temp=0,ref=0;
   while(h<=compare.length()-1)
   {
    while(i<=n)
    {
        
        while(j<=a.length()-1)
        {
           
            
           if( compare.charAt(i)==a.charAt(j) )
           {
               
               count+=1;
               temp+=1;
                k=j;
               System.out.print(a.charAt(j));
           }
          
           if(temp>0)
           {
               j=a.length();
           }
           j++;
           
        }
        i++;
        j=k+1;
        temp=0;
    }
    System.out.print(" ");
      if(ref<count)
      {
          ref=count;
      }
      
    //System.out.print( "      " + "count:"+count);
   // System.out.println("\n");
    h++;
    i=h;
    j=0;
    count=0;
   }
   System.out.println("\n\n LCS count: "+ref);
    
    
}

    public static void main(String args[])
    {
        String a="abcdefghijklm";
        String compare="dacegfkmi";
        lcs(a,compare);
    }
    
    
}
	
}
---------------------------------------------------------------------------------------------------------------------------------------------------------

[12:23 PM] Maria (Unverified)
package com.commoncode;
 
class FirstClass{
	public  FirstClass()
	{super();
		System.out.println("1");
	}
}
class SecondClass extends FirstClass{
	public  SecondClass()
	{
		super();
		System.out.println("2");
	}
}
class ThirdClass extends SecondClass{
	public  ThirdClass()
	{
		System.out.println("3");
	}
}
public class Main {
 
	public static void main(String[] args) {
		ThirdClass t=new ThirdClass();
 
	}
 
}
 
[12:23 PM] Maria (Unverified)
aaaaa
[12:23 PM] Maria (Unverified)
package com.commoncode;
 
 
import java.util.Arrays;
 
public class NestedforLoopEx {
 
	public static void main(String[] args) {
		int[] array= new int[5];
		for(int j=5;j>0;j--)
		{			array[5-j]=j;
			}
			Arrays.fill(array,1,5,8);
			
			for(int j=0;j<5;j++)
			{
				System.out.print(array[j]);
		}
		
	}
 
}
[12:23 PM] Maria (Unverified)
bbbbb
[12:24 PM] Maria (Unverified)
package com.commoncode;
 
 
interface An{
	default void show() {
		System.out.println("A");
	}
}
interface Bn{
	default void show() {
		System.out.println("B");
	}
}
class C implements An,Bn{
 
	@Override
	public void show() {
		// TODO Auto-generated method stub
		An.super.show();
	}
	
}
 
public class Test2 {
 
	public static void main(String[] args) {
 
C c=new C();
c.show();
 
	}
 
}
 
[12:24 PM] Maria (Unverified)
cccc
[12:24 PM] Maria (Unverified)
package com.commoncode;
 
public class Test6 {
	public static void main(String[] args) {
		int x=-4;
		System.out.println(x>>1);
		int y=4;
		System.out.println(y>>1);;
 
	}
}
 
[12:24 PM] Maria (Unverified)
dddd
[12:24 PM] Maria (Unverified)
package com.commoncode;
 
 
class Base{
	static String s="Super class";
public	Base(){
		System.out.printf("1");
	}
}
 
public class Derived extends Base {
	public Derived() {
		super(); //1 2
		System.out.printf("2");
			
	}
	
	public static void main(String[] args) {
		Derived d=new Derived();
	}
}
[12:24 PM] Maria (Unverified)
eeee
[12:24 PM] Maria (Unverified)
package com.commoncode;
 
//private - default,protected,public
 
class A{
	int i;
	void display() {
		System.out.println(i);
	
	}
}
class B extends A{
	int j;
		void  display() {
		System.out.println(j);
	
	}
}
public class InheritanceDemo {
 
	public static void main(String[] args) {
	
B obj=new B();
obj.i=1;
obj.j=2;
obj.display();
	}
 
}

---------------------------------------------------------------------------------------------------------------------------------------------

public class KnightsTour {
    private static final int N = 8;

    private static boolean isSafe(int x, int y, int[][] board) {
        return (x >= 0 && x < N && y >= 0 && y < N && board[x][y] == -1);
    }

    private static boolean solveKnightsTour(int[][] board, int x, int y, int moveCount, int[] xMove, int[] yMove) {
        if (moveCount == N * N) {
            return true;
        }

        for (int i = 0; i < 8; i++) {
            int nextX = x + xMove[i];
            int nextY = y + yMove[i];
            if (isSafe(nextX, nextY, board)) {
                board[nextX][nextY] = moveCount;
                if (solveKnightsTour(board, nextX, nextY, moveCount + 1, xMove, yMove)) {
                    return true;
                } else {
                    board[nextX][nextY] = -1; // backtrack
                }
            }
        }

        return false;
    }

    public static void main(String[] args) {
        int[][] board = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1; // Initialize all cells as unvisited
            }
        }

        int[] xMove = {2, 1, -1, -2, -2, -1, 1, 2};
        int[] yMove = {1, 2, 2, 1, -1, -2, -2, -1};

        int startX = 0, startY = 0; // Starting position of the knight
        board[startX][startY] = 0; // Mark the starting cell as visited

        if (solveKnightsTour(board, startX, startY, 1, xMove, yMove)) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(board[i][j] + " ");
                }
                System.out.println();
            }
        } else {
            System.out.println("No solution exists.");
        }
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------
    public class OptimalBinarySearchTree {
    public static void main(String[] args) {
        double[] keys = {10, 12, 20};
        double[] freq = {34, 8, 50};
        int n = keys.length;
        System.out.println("Cost of Optimal BST is " + optimalSearchTree(keys, freq, n));
    }

    private static double optimalSearchTree(double[] keys, double[] freq, int n) {
        double[][] cost = new double[n + 1][n + 1];

        for (int i = 0; i < n; i++) {
            cost[i][i] = freq[i];
        }

        for (int length = 2; length <= n; length++) {
            for (int i = 0; i <= n - length + 1; i++) {
                int j = i + length - 1;
                cost[i][j] = Double.MAX_VALUE;
                double sum = getSum(freq, i, j);

                for (int k = i; k <= j; k++) {
                    double temp = ((k > i) ? cost[i][k - 1] : 0) +
                                  ((k < j) ? cost[k + 1][j] : 0) + sum;
                    if (temp < cost[i][j]) {
                        cost[i][j] = temp;
                    }
                }
            }
        }
        return cost[0][n - 1];
    }

    private static double getSum(double[] freq, int i, int j) {
        double sum = 0;
        for (int k = i; k <= j; k++) {
            sum += freq[k];
        }
        return sum;
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------

public class OptimalBinarySearchTree {
    public static void main(String[] args) {
        double[] keys = {10, 12, 20};
        double[] freq = {34, 8, 50};
        int n = keys.length;
        System.out.println("Cost of Optimal BST is " + optimalSearchTree(keys, freq, n));
    }

    private static double optimalSearchTree(double[] keys, double[] freq, int n) {
        double[][] cost = new double[n][n];

        for (int i = 0; i < n; i++) {
            cost[i][i] = freq[i];
        }

        for (int length = 2; length <= n; length++) {
            for (int i = 0; i <= n - length; i++) {
                int j = i + length - 1;
                cost[i][j] = Double.MAX_VALUE;
                double sum = getSum(freq, i, j);

                for (int k = i; k <= j; k++) {
                    double temp = ((k > i) ? cost[i][k - 1] : 0) +
                                  ((k < j) ? cost[k + 1][j] : 0) + sum;
                    if (temp < cost[i][j]) {
                        cost[i][j] = temp;
                    }
                }
            }
        }
        return cost[0][n - 1];
    }

    private static double getSum(double[] freq, int i, int j) {
        double sum = 0;
        for (int k = i; k <= j; k++) {
            sum += freq[k];
        }
        return sum;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------
public class RatInMaze
{
    private static int[,] solution;

    public static bool SolveMaze(int[,] maze)
    {
        int n = maze.GetLength(0);
        solution = new int[n, n];

        if (SolveMazeUtil(maze, 0, 0))
        {
            PrintSolution(solution);
            return true;
        }

        Console.WriteLine("No solution found");
        return false;
    }

    private static bool SolveMazeUtil(int[,] maze, int x, int y)
    {
        int n = maze.GetLength(0);

        if (x == n - 1 && y == n - 1 && maze[x, y] == 1)
        {
            solution[x, y] = 1;
            return true;
        }

        if (IsSafe(maze, x, y))
        {
            solution[x, y] = 1;

            if (SolveMazeUtil(maze, x + 1, y))
                return true;

            if (SolveMazeUtil(maze, x, y + 1))
                return true;

            solution[x, y] = 0;
            return false;
        }

        return false;
    }

    private static bool IsSafe(int[,] maze, int x, int y)
    {
        int n = maze.GetLength(0);
        return (x >= 0 && x < n && y >= 0 && y < n && maze[x, y] == 1);
    }

    private static void PrintSolution(int[,] solution)
    {
        int n = solution.GetLength(0);
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                Console.Write(solution[i, j] + " ");
            }
            Console.WriteLine();
        }
    }
}

----------------------------------------------------------------------------------------------------------------------------------------

public class NQueenProblem {
    final int N = 8;

    boolean solveNQueen(int board[][], int col) {
        if (col >= N)
            return true;

        for (int i = 0; i < N; i++) {
            if (isSafe(board, i, col)) {
                board[i][col] = 1;

                if (solveNQueen(board, col + 1))
                    return true;

                board[i][col] = 0;
            }
        }

        return false;
    }

    boolean isSafe(int board[][], int row, int col) {
        int i, j;

        for (i = 0; i < col; i++)
            if (board[row][i] == 1)
                return false;

        for (i = row, j = col; i >= 0 && j >= 0; i--, j--)
            if (board[i][j] == 1)
                return false;

        for (i = row, j = col; j >= 0 && i < N; i++, j--)
            if (board[i][j] == 1)
                return false;

        return true;
    }

    void printSolution(int board[][]) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++)
                System.out.print(" " + board[i][j]
                                 + " ");
            System.out.println();
        }
    }

    public static void main(String args[]) {
        NQueenProblem Queen = new NQueenProblem();
        int board[][] = new int[Queen.N][Queen.N];
        if (!Queen.solveNQueen(board, 0)) {
            System.out.print("Solution does not exist");
            return;
        }

        Queen.printSolution(board);
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------


public class RatInMaze {
    private static int N = 6;

    public static boolean solveMaze(int[][] maze) {
        int[][] solution = new int[N][N];
        if (solveMazeUtil(maze, 0, 0, solution)) {
            printSolution(solution);
            return true;
        }
        System.out.println("No solution found");
        return false;
    }

    private static boolean solveMazeUtil(int[][] maze, int x, int y, int[][] solution) {
        if (x == N - 1 && y == N - 1 && maze[x][y] == 1) {
            solution[x][y] = 1;
            return true;
        }

        if (isSafe(maze, x, y)) {
            solution[x][y] = 1;

            if (solveMazeUtil(maze, x + 1, y, solution))
                return true;

            if (solveMazeUtil(maze, x, y + 1, solution))
                return true;

            solution[x][y] = 0;
            return false;
        }

        return false;
    }

    private static boolean isSafe(int[][] maze, int x, int y) {
        return (x >= 0 && x < N && y >= 0 && y < N && maze[x][y] == 1);
    }

    private static void printSolution(int[][] solution) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(solution[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[][] maze = {
            { 1, 0, 0, 0, 0, 0 },
            { 1, 1, 0, 1, 1, 1 },
            { 0, 1, 0, 1, 0, 0 },
            { 1, 1, 1, 1, 0, 1 },
            { 0, 0, 0, 0, 1, 0 },
            { 1, 1, 1, 1, 1, 1 }
        };

        solveMaze(maze);
    }
}
------------------------------------------------------------------------------------------------------------------------
public class NQueenProblem {
    final int N = 8;

    boolean solveNQueen(int board[][], int col) {
        if (col >= N)
            return true;

        for (int i = 0; i < N; i++) {
            if (isSafe(board, i, col)) {
                board[i][col] = 1;

                if (solveNQueen(board, col + 1))
                    return true;

                board[i][col] = 0;
            }
        }

        return false;
    }

    boolean isSafe(int board[][], int row, int col) {
        for (int i = 0; i < col; i++)
            if (board[row][i] == 1)
                return false;

        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)
            if (board[i][j] == 1)
                return false;

        for (int i = row, j = col; j >= 0 && i < N; i++, j--)
            if (board[i][j] == 1)
                return false;

        return true;
    }

    void printSolution(int board[][]) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++)
                System.out.print(" " + board[i][j] + " ");
            System.out.println();
        }
    }

    public static void main(String args[]) {
        NQueenProblem Queen = new NQueenProblem();
        int board[][] = new int[Queen.N][Queen.N];
        if (!Queen.solveNQueen(board, 0)) {
            System.out.print("Solution does not exist");
            return;
        }

        Queen.printSolution(board);
    }
}
---------------------------------------------------------------------------------------------------------------------------------

implementation.....

public class KnightsTour {
	 private static final int[] dx = {2, 1, -1, -2, -2, -1, 1, 2};
	    private static final int[] dy = {1, 2, 2, 1, -1, -2, -2, -1};
	    private static final int N = 8;
 
	    public static void main(String[] args) {
	        solveKnightsTour();
	    }
 
	    private static void solveKnightsTour() {
	        int[][] board = new int[N][N];
 
	        // Initialize the board with -1 indicating unvisited squares
	        for (int i = 0; i < N; i++) {
	            for (int j = 0; j < N; j++) {
	                board[i][j] = -1;
	            }
	        }
 
	        // Knight starts at the first block
	        board[0][0] = 0;
 
	        if (solveKTUtil(0, 0, 1, board)) {
	            printSolution(board);
	        } else {
	            System.out.println("Solution does not exist");
	        }
	    }
 
	    private static boolean solveKTUtil(int x, int y, int movei, int[][] board) {
	        if (movei == N * N) {
	            return true;
	        }
 
	        for (int k = 0; k < 8; k++) {
	            int nextX = x + dx[k];
	            int nextY = y + dy[k];
	            if (isSafe(nextX, nextY, board)) {
	                board[nextX][nextY] = movei;
	                if (solveKTUtil(nextX, nextY, movei + 1, board)) {
	                    return true;
	                } else {
	                    board[nextX][nextY] = -1; // backtracking
	                }
	            }
	        }
	        return false;
	    }
 
	    private static boolean isSafe(int x, int y, int[][] board) {
	        return (x >= 0 && x < N && y >= 0 && y < N && board[x][y] == -1);
	    }
 
	    private static void printSolution(int[][] board) {
	        for (int i = 0; i < N; i++) {
	            for (int j = 0; j < N; j++) {
	                System.out.printf("%2d ", board[i][j]);
	            }
	            System.out.println();
	        }
	    }
}

------------------------------------------------------------------------------------------------------------------------------------------------

com.backtrackingalgorithms;
import java.util.*;
public class SubsetSumBacktracking {
	 // Function to find all subsets of the given set that sum up to the target
    static void findSubsets(int[] set, int target) {
        Arrays.sort(set);  // Optional: Sorting helps in pruning the search space
        List<Integer> currentSubset = new ArrayList<>();
        findSubsetsHelper(set, target, 0, currentSubset);
    }
 
    // Helper function for the backtracking approach
    static void findSubsetsHelper(int[] set, int target, int index, List<Integer> currentSubset) {
        if (target == 0) {
            // If the target is achieved, print the current subset
            System.out.println(currentSubset);
            return;
        }
 
        for (int i = index; i < set.length; i++) {
            // Skip if the current element is greater than the remaining target
            if (set[i] > target) {
                break;
            }
 
            // Include the current element in the subset
            currentSubset.add(set[i]);
 
            // Recurse with the reduced target and next index
            findSubsetsHelper(set, target - set[i], i + 1, currentSubset);
 
            // Backtrack: remove the last added element and try the next element
            currentSubset.remove(currentSubset.size() - 1);
        }
    }
 
    public static void main(String[] args) {
        int[] set = {10,20,30,40};
        int target = 50;
        System.out.println("Subsets with sum " + target + ":");
        findSubsets(set, target);
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------
MergeSortedLinkedList

class MergeListNode {
    int val;
    MergeListNode next;

    MergeListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class MergeSortedLinkedList {
    public static MergeListNode mergeTwoLists(MergeListNode l1, MergeListNode l2) {
        // Create a dummy node to simplify the merge process
        MergeListNode dummy = new MergeListNode(-1);
        MergeListNode current = dummy;

        // Merge the lists while both have nodes remaining
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        // Attach the remaining nodes, if any
        if (l1 != null) {
            current.next = l1;
        } else {
            current.next = l2;
        }

        // Return the merged list, skipping the dummy node
        return dummy.next;
    }

    public static void printList(MergeListNode head) {
        MergeListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create first sorted linked list: 1 -> 3 -> 5
        MergeListNode l1 = new MergeListNode(1);
        l1.next = new MergeListNode(3);
        l1.next.next = new MergeListNode(5);

        // Create second sorted linked list: 2 -> 4 -> 6
        MergeListNode l2 = new MergeListNode(2);
        l2.next = new MergeListNode(4);
        l2.next.next = new MergeListNode(6);

        // Merge the lists
        MergeListNode mergedList = mergeTwoLists(l1, l2);

        // Print the merged list
        System.out.print("Merged List: ");
        printList(mergedList);
    }
}

------------------------------------------------------------------------------------------------------------------------

MiddleElementFind

class MiddleListNode {
    int val;
    MiddleListNode next;

    MiddleListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class FindMiddleElement {
    public static MiddleListNode findMiddle(MiddleListNode head) {
        if (head == null) {
            return null;
        }

        MiddleListNode slow = head;
        MiddleListNode fast = head;

        // Move fast pointer twice as fast as the slow pointer
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Slow pointer will be at the middle when fast pointer reaches the end
        return slow;
    }

    public static void printList(MiddleListNode head) {
        MiddleListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create a linked list: 1 -> 2 -> 3 -> 4 -> 5
        MiddleListNode head = new MiddleListNode(1);
        head.next = new MiddleListNode(2);
        head.next.next = new MiddleListNode(3);
        head.next.next.next = new MiddleListNode(4);
        head.next.next.next.next = new MiddleListNode(5);

        // Print the list
        System.out.print("Linked List: ");
        printList(head);

        // Find the middle element
        MiddleListNode middle = findMiddle(head);
        System.out.println("Middle Element: " + (middle != null ? middle.val : "List is empty"));
    }
}
------------------------------------------------------------------------------------------------------------------------------------------

[2:33 PM] Maria (Unverified)
package com.backtrackingalgorithms;
 
public class RatInMaze {
	private static final int N = 4;
 
    // Utility function to print the solution matrix
    private void printSolution(int[][] sol) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(" " + sol[i][j] + " ");
            }
            System.out.println();
        }
    }
 
    // A utility function to check if x, y is valid index for N*N maze
    private boolean isSafe(int[][] maze, int x, int y) {
        return (x >= 0 && x < N && y >= 0 && y < N && maze[x][y] == 1);
    }
 
    // This function solves the Maze problem using Backtracking.
    // It mainly uses solveMazeUtil() to solve the problem.
    // It returns false if no path is possible, otherwise returns true and
    // prints the path in the form of 1s. Please note that there may be more
    // than one solutions, this function prints one of the feasible solutions.
    private boolean solveMaze(int[][] maze) {
        int[][] sol = {
                {0, 0, 0, 0},
                {0, 0, 0, 0},
                {0, 0, 0, 0},
                {0, 0, 0, 0}
        };
 
        if (!solveMazeUtil(maze, 0, 0, sol)) {
            System.out.println("Solution doesn't exist");
            return false;
        }
 
        printSolution(sol);
        return true;
    }
 
    // A recursive utility function to solve Maze problem
    private boolean solveMazeUtil(int[][] maze, int x, int y, int[][] sol) {
        // If (x, y is goal) return true
        if (x == N - 1 && y == N - 1) {
            sol[x][y] = 1;
            return true;
        }
 
        // Check if maze[x][y] is valid
        if (isSafe(maze, x, y)) {
            // Mark x, y as part of solution path
            sol[x][y] = 1;
 
            // Move forward in x direction
            if (solveMazeUtil(maze, x + 1, y, sol)) {
                return true;
            }
 
            // If moving in x direction doesn't give solution then
            // Move down in y direction
            if (solveMazeUtil(maze, x, y + 1, sol)) {
                return true;
            }
 
            // If moving in y direction doesn't give solution then
            // Move back in x direction
            if (solveMazeUtil(maze, x - 1, y, sol)) {
                return true;
            }
 
            // If moving back in x direction doesn't give solution then
            // Move back in y direction
            if (solveMazeUtil(maze, x, y - 1, sol)) {
                return true;
            }
 
            // If none of the above movements work then
            // BACKTRACK: unmark x, y as part of solution path
            sol[x][y] = 0;
            return false;
        }
 
        return false;
    }
 
    public static void main(String[] args) {
        RatInMaze rat = new RatInMaze();
        int[][] maze = {
                {1, 0, 0, 0},
                {1, 1, 0, 1},
                {0, 1, 0, 0},
                {1, 1, 1, 1}
        };
        rat.solveMaze(maze);
    }
}
 
[2:34 PM] Maria (Unverified)
package com.backtrackingalgorithms;
 
public class KnightsTour {
	 private static final int[] dx = {2, 1, -1, -2, -2, -1, 1, 2};
	    private static final int[] dy = {1, 2, 2, 1, -1, -2, -2, -1};
	    private static final int N = 8;
 
	    public static void main(String[] args) {
	        solveKnightsTour();
	    }
 
	    private static void solveKnightsTour() {
	        int[][] board = new int[N][N];
 
	        // Initialize the board with -1 indicating unvisited squares
	        for (int i = 0; i < N; i++) {
	            for (int j = 0; j < N; j++) {
	                board[i][j] = -1;
	            }
	        }
 
	        // Knight starts at the first block
	        board[0][0] = 0;
 
	        if (solveKTUtil(0, 0, 1, board)) {
	            printSolution(board);
	        } else {
	            System.out.println("Solution does not exist");
	        }
	    }
 
	    private static boolean solveKTUtil(int x, int y, int movei, int[][] board) {
	        if (movei == N * N) {
	            return true;
	        }
 
	        for (int k = 0; k < 8; k++) {
	            int nextX = x + dx[k];
	            int nextY = y + dy[k];
	            if (isSafe(nextX, nextY, board)) {
	                board[nextX][nextY] = movei;
	                if (solveKTUtil(nextX, nextY, movei + 1, board)) {
	                    return true;
	                } else {
	                    board[nextX][nextY] = -1; // backtracking
	                }
	            }
	        }
	        return false;
	    }
 
	    private static boolean isSafe(int x, int y, int[][] board) {
	        return (x >= 0 && x < N && y >= 0 && y < N && board[x][y] == -1);
	    }
 
	    private static void printSolution(int[][] board) {
	        for (int i = 0; i < N; i++) {
	            for (int j = 0; j < N; j++) {
	                System.out.printf("%2d ", board[i][j]);
	            }
	            System.out.println();
	        }
	    }
}

----------------------------------------------------------------------------

package com.backtrackingalgorithms;
 
public class KnightsTour {
	 private static final int[] dx = {2, 1, -1, -2, -2, -1, 1, 2};
	    private static final int[] dy = {1, 2, 2, 1, -1, -2, -2, -1};
	    private static final int N = 8;
 
	    public static void main(String[] args) {
	        solveKnightsTour();
	    }
 
	    private static void solveKnightsTour() {
	        int[][] board = new int[N][N];
 
	        // Initialize the board with -1 indicating unvisited squares
	        for (int i = 0; i < N; i++) {
	            for (int j = 0; j < N; j++) {
	                board[i][j] = -1;
	            }
	        }
 
	        // Knight starts at the first block
	        board[0][0] = 0;
 
	        if (solveKTUtil(0, 0, 1, board)) {
	            printSolution(board);
	        } else {
	            System.out.println("Solution does not exist");
	        }
	    }
 
	    private static boolean solveKTUtil(int x, int y, int movei, int[][] board) {
	        if (movei == N * N) {
	            return true;
	        }
 
	        for (int k = 0; k < 8; k++) {
	            int nextX = x + dx[k];
	            int nextY = y + dy[k];
	            if (isSafe(nextX, nextY, board)) {
	                board[nextX][nextY] = movei;
	                if (solveKTUtil(nextX, nextY, movei + 1, board)) {
	                    return true;
	                } else {
	                    board[nextX][nextY] = -1; // backtracking
	                }
	            }
	        }
	        return false;
	    }
 
	    private static boolean isSafe(int x, int y, int[][] board) {
	        return (x >= 0 && x < N && y >= 0 && y < N && board[x][y] == -1);
	    }
 
	    private static void printSolution(int[][] board) {
	        for (int i = 0; i < N; i++) {
	            for (int j = 0; j < N; j++) {
	                System.out.printf("%2d ", board[i][j]);
	            }
	            System.out.println();
	        }
	    }
}
 ---------------------------------------------------------------------------------------------------------------------------------------

package com.thread;
import java.util.LinkedList;
import java.util.Queue;
 
class SharedResource {
    private final Queue<Integer> queue = new LinkedList<>();
    private final int MAX_SIZE = 5;
 
    public synchronized void produce(int value) throws InterruptedException {
        while (queue.size() == MAX_SIZE) {
            wait();
        }
        queue.add(value);
        notifyAll();// Waking up all threads
    }
 
    public synchronized int consume() throws InterruptedException {
        while (queue.isEmpty()) {
            wait();
        }
        int value = queue.poll();
        notifyAll();
        return value;
    }
}
 
class Producer implements Runnable {
    private final SharedResource resource;
 
    public Producer(SharedResource resource) {
        this.resource = resource;
    }
 
    @Override
    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                resource.produce(i);
                System.out.println("Produced: " + i);
                Thread.sleep(100);// delay
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
 
class Consumer implements Runnable {
    private final SharedResource resource;
 
    public Consumer(SharedResource resource) {
        this.resource = resource;
    }
 
    @Override
    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                int value = resource.consume();
                System.out.println("Consumed: " + value);
                Thread.sleep(150);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
 
public class ProducerConsumerExample {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        Thread producerThread = new Thread(new Producer(resource));
        Thread consumerThread = new Thread(new Consumer(resource));
 
        producerThread.start();
        consumerThread.start();
    }
}
 ------------------------------------------------------------------------------------------------------------------------

Task1:

public class ThreadExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new NumberPrinter());
        Thread thread2 = new Thread(new NumberPrinter());

        thread1.start();
        thread2.start();
    }
}

class NumberPrinter implements Runnable {
    public void run() {
        for (int i = 1; i <= 10; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
            try {
                Thread.sleep(1000); // 1-second delay
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
---------------------------------------------------------------------------------------------------

Task2:

public class ThreadStateExample {
    public static void main(String[] args) {
        ThreadStateDemo threadStateDemo = new ThreadStateDemo();

        System.out.println("State after creating thread: " + threadStateDemo.getState());
        threadStateDemo.start();
        System.out.println("State after starting thread: " + threadStateDemo.getState());

        try {
            Thread.sleep(500);
            synchronized (threadStateDemo) {
                System.out.println("State after synchronized block: " + threadStateDemo.getState());
                threadStateDemo.wait(500);
            }
            System.out.println("State after wait: " + threadStateDemo.getState());

            threadStateDemo.join();
            System.out.println("State after join: " + threadStateDemo.getState());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class ThreadStateDemo extends Thread {
    public void run() {
        try {
            synchronized (this) {
                Thread.sleep(1000);
            }
            synchronized (this) {
                this.notify();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

-------------------------------------------------------------------------------------
Task3:

import java.util.LinkedList;
import java.util.Queue;

public class ProducerConsumerExample {
    public static void main(String[] args) {
        Queue<Integer> buffer = new LinkedList<>();
        int maxSize = 10;
        Thread producer = new Thread(new Producer(buffer, maxSize), "Producer");
        Thread consumer = new Thread(new Consumer(buffer), "Consumer");

        producer.start();
        consumer.start();
    }
}

class Producer implements Runnable {
    private final Queue<Integer> buffer;
    private final int maxSize;

    public Producer(Queue<Integer> buffer, int maxSize) {
        this.buffer = buffer;
        this.maxSize = maxSize;
    }

    @Override
    public void run() {
        int i = 0;
        while (true) {
            synchronized (buffer) {
                while (buffer.size() == maxSize) {
                    try {
                        buffer.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                buffer.add(i++);
                buffer.notifyAll();
            }
        }
    }
}

class Consumer implements Runnable {
    private final Queue<Integer> buffer;

    public Consumer(Queue<Integer> buffer) {
        this.buffer = buffer;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (buffer) {
                while (buffer.isEmpty()) {
                    try {
                        buffer.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                buffer.poll();
                buffer.notifyAll();
            }
        }
    }
}
---------------------------------------------------------------------------------------------------------

Task4:

public class BankAccountExample {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                account.deposit(100);
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                account.withdraw(50);
            }
        });

        t1.start();
        t2.start();
    }
}

class BankAccount {
    private int balance = 0;

    public synchronized void deposit(int amount) {
        balance += amount;
        System.out.println("Deposited " + amount + ", balance is now " + balance);
    }

    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount;
            System.out.println("Withdrew " + amount + ", balance is now " + balance);
        } else {
            System.out.println("Not enough balance to withdraw " + amount + ", balance is " + balance);
        }
    }
}

--------------------------------------------------------------------------------------------------------

package com.thread;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
 
public class ThreadPoolExample {
    public static void main(String[] args) {
        // Create a fixed thread pool with 3 threads
        ExecutorService executor = Executors.newFixedThreadPool(3);
 
        // Submit tasks for execution
        for (int i = 1; i <= 5; i++) {
            Runnable task = new Task("Task " + i);
            executor.submit(task);
        }
 
        // Shutdown the executor
        executor.shutdown();
    }
}
 
class Task implements Runnable {
    private String name;
 
    public Task(String name) {
        this.name = name;
    }
 
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " executing " + name);
        try {
            Thread.sleep(1000); // Simulate some work
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println(Thread.currentThread().getName() + " finished " + name);
    }
}
----------------------------------------------------------------------------------------------------------------------

task5:

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(4);

        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                System.out.println("Task started by " + Thread.currentThread().getName());
                try {
                    Thread.sleep(2000); // Simulate complex calculation or I/O operation
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Task completed by " + Thread.currentThread().getName());
            });
        }

        executor.shutdown();
    }
}

-----------------------------------------------------------------------------------------------------------------

task6:
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class PrimeCalculator {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(4);
        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (int i = 1; i <= 100; i++) {
            int num = i;
            futures.add(CompletableFuture.supplyAsync(() -> isPrime(num), executor)
                    .thenAcceptAsync(isPrime -> {
                        if (isPrime) {
                            try (BufferedWriter writer = new BufferedWriter(new FileWriter("primes.txt", true))) {
                                writer.write(num + "\n");
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }, executor));
        }

        CompletableFuture<Void> allOf = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
        allOf.join();
        executor.shutdown();
    }

    public static boolean isPrime(int number) {
        if (number <= 1) return false;
        for (int i = 2; i < Math.sqrt(number) + 1; i++) {
            if (number % i == 0) return false;
        }
        return true;
    }
}

------------------------------------------------------------------------------------------------------------

task 7:

import java.util.concurrent.atomic.AtomicInteger;

class Counter {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();
    }

    public void decrement() {
        count.decrementAndGet();
    }

    public int getValue() {
        return count.get();
    }
}

public class CounterExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println("Final count: " + counter.getValue());
    }
}

final class ImmutableData {
    private final int value;

    public ImmutableData(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}

public class ImmutableDataExample {
    public static void main(String[] args) {
        ImmutableData data = new ImmutableData(42);
        Runnable task = () -> {
            System.out.println("Immutable data value: " + data.getValue());
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);

        thread1.start();
        thread2.start();
    }
}
-----------------------------------------------------------------------------------------------------------------------
task 1 :

public class Pair<T, U> {
    private T first;
    private U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public void setFirst(T first) {
        this.first = first;
    }

    public U getSecond() {
        return second;
    }

    public void setSecond(U second) {
        this.second = second;
    }

    // Method to return a reversed version of the pair
    public Pair<U, T> reverse() {
        return new Pair<>(second, first);
    }

    @Override
    public String toString() {
        return "Pair{" + "first=" + first + ", second=" + second + '}';
    }

    public static void main(String[] args) {
        Pair<Integer, String> pair = new Pair<>(1, "one");
        System.out.println("Original Pair: " + pair);
        Pair<String, Integer> reversedPair = pair.reverse();
        System.out.println("Reversed Pair: " + reversedPair);
    }
}

-------------------------------------------------------------------------------------------------------

task 2:

import java.util.Arrays;

public class ArrayUtil {

    // Generic method to swap two elements in an array
    public static <T> void swap(T[] array, int index1, int index2) {
        T temp = array[index1];
        array[index1] = array[index2];
        array[index2] = temp;
    }

    public static void main(String[] args) {
        // Demonstrate usage with different object types

        // Integer array
        Integer[] intArray = {1, 2, 3, 4, 5};
        System.out.println("Before swap (Integer array): " + Arrays.toString(intArray));
        swap(intArray, 1, 3);
        System.out.println("After swap (Integer array): " + Arrays.toString(intArray));

        // String array
        String[] strArray = {"a", "b", "c", "d", "e"};
        System.out.println("Before swap (String array): " + Arrays.toString(strArray));
        swap(strArray, 0, 4);
        System.out.println("After swap (String array): " + Arrays.toString(strArray));

        // Double array
        Double[] doubleArray = {1.1, 2.2, 3.3, 4.4, 5.5};
        System.out.println("Before swap (Double array): " + Arrays.toString(doubleArray));
        swap(doubleArray, 2, 4);
        System.out.println("After swap (Double array): " + Arrays.toString(doubleArray));
    }
}
----------------------------------------------------------------------------------------------------------------------
