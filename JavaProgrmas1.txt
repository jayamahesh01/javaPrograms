public class TowerOfHanoi {
    
    // Recursive function to solve Tower of Hanoi puzzle
    public static void solveHanoi(int n, char fromRod, char toRod, char auxRod) {
        // Base case: If only one disk, move it from source to destination
        if (n == 1) {
            System.out.println("Move disk 1 from rod " + fromRod + " to rod " + toRod);
            return;
        }
        
        // Recursive case: Move top n-1 disks from source to auxiliary rod
        solveHanoi(n - 1, fromRod, auxRod, toRod);
        
        // Move the nth disk from source to destination rod
        System.out.println("Move disk " + n + " from rod " + fromRod + " to rod " + toRod);
        
        // Move the n-1 disks from auxiliary rod to destination rod
        solveHanoi(n - 1, auxRod, toRod, fromRod);
    }
    
    public static void main(String[] args) {
        int n = 3; // Number of disks
        solveHanoi(n, 'A', 'C', 'B'); // Names of rods: A is source, C is destination, B is auxiliary
    }
}

------------------------------------------------------------------------------------------------------------------------------


public class TowerOfHanoi {

    public static void solveHanoi(int n, char source, char auxiliary, char destination) {
        if (n == 1) {
            System.out.println("Move disk 1 from " + source + " to " + destination);
            return;
        }

        solveHanoi(n - 1, source, destination, auxiliary);
        System.out.println("Move disk " + n + " from " + source + " to " + destination);
        solveHanoi(n - 1, auxiliary, source, destination);
    }

    public static void main(String[] args) {
        int n = 3;
        solveHanoi(n, 'A', 'B', 'C');
    }
}
--------------------------------------------------------------------------------------------------------------------------------

task 2:

public class TravelingSalesmanProblem {

    public static int findMinCost(int[][] graph) {
        int n = graph.length;
        int[][] dp = new int[1 << n][n];

        for (int[] row : dp) {
            Arrays.fill(row, Integer.MAX_VALUE / 2); // Initialize with a large value to avoid overflow
        }

        dp[1][0] = 0; // Starting city is 0

        for (int mask = 1; mask < (1 << n); mask += 2) {
            for (int i = 1; i < n; i++) {
                if ((mask & (1 << i)) != 0) {
                    for (int j = 0; j < n; j++) {
                        if ((mask & (1 << j)) != 0) {
                            dp[mask][i] = Math.min(dp[mask][i], dp[mask ^ (1 << i)][j] + graph[j][i]);
                        }
                    }
                }
            }
        }

        int minCost = Integer.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            minCost = Math.min(minCost, dp[(1 << n) - 1][i] + graph[i][0]);
        }

        return minCost;
    }

    public static void main(String[] args) {
        int[][] graph = {
            {0, 10, 15, 20},
            {10, 0, 35, 25},
            {15, 35, 0, 30},
            {20, 25, 30, 0}
        };
        System.out.println("Minimum cost to visit all cities: " + findMinCost(graph));
    }
}



--------------------------------------------------------------------------------------------------------------------------


implementation:   

com.computationalalgorithms;
 
public class TravelingSalesman {
	 // Function to solve the TSP using Dynamic Programming
    public static int tsp(int[][] dist) {
        int n = dist.length;
        int VISITED_ALL = (1 << n) - 1;
        int[][] dp = new int[1 << n][n];
 
        // Initialize dp array with a large value
        for (int i = 0; i < (1 << n); i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
 
        // Base case: starting from the first city
        dp[1][0] = 0;
 
        // Iterate over all subsets of cities
        for (int mask = 1; mask < (1 << n); mask++) {
            for (int i = 0; i < n; i++) {
                // Continue if the ith city is not in the subset represented by mask
                if ((mask & (1 << i)) == 0) continue;
 
                // Try to find the minimum cost path to city i
                for (int j = 0; j < n; j++) {
                    if ((mask & (1 << j)) != 0 && i != j) {
                        dp[mask][i] = Math.min(dp[mask][i], dp[mask ^ (1 << i)][j] + dist[j][i]);
                    }
                }
            }
        }
 
        // Find the minimum cost to visit all cities and return to the starting city
        int minCost = Integer.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            minCost = Math.min(minCost, dp[VISITED_ALL][i] + dist[i][0]);
        }
 
        return minCost;
    }
 
    public static void main(String[] args) {
        int[][] dist = {
            {0, 10, 15, 20},
            {10, 0, 35, 25},
            {15, 35, 0, 30},
            {20, 25, 30, 0}
        };
 
        System.out.println("The minimum cost is " + tsp(dist));
    }
}


--------------------------------------------------------------------------------------------------------------------------------------

task 3:

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Job {
    int Id, Deadline, Profit;

    public Job(int Id, int Deadline, int Profit) {
        this.Id = Id;
        this.Deadline = Deadline;
        this.Profit = Profit;
    }
}

public class JobSequencing {
    
    public static List<Job> JobSequencing(List<Job> jobs) {
        // Step 1: Sort jobs by profit in descending order
        Collections.sort(jobs, (a, b) -> b.Profit - a.Profit);
        
        // Step 2: Find the maximum deadline
        int maxDeadline = 0;
        for (Job job : jobs) {
            if (job.Deadline > maxDeadline) {
                maxDeadline = job.Deadline;
            }
        }
        
        // Step 3: Create a schedule array to keep track of free time slots
        int[] schedule = new int[maxDeadline];
        for (int i = 0; i < maxDeadline; i++) {
            schedule[i] = -1;
        }
        
        // Step 4: Schedule jobs
        List<Job> result = new ArrayList<>();
        for (Job job : jobs) {
            // Find a time slot from job.Deadline to 1
            for (int j = job.Deadline - 1; j >= 0; j--) {
                if (schedule[j] == -1) {
                    schedule[j] = job.Id;
                    result.add(job);
                    break;
                }
            }
        }
        
        return result;
    }

    public static void main(String[] args) {
        List<Job> jobs = new ArrayList<>();
        jobs.add(new Job(1, 2, 100));
        jobs.add(new Job(2, 1, 19));
        jobs.add(new Job(3, 2, 27));
        jobs.add(new Job(4, 1, 25));
        jobs.add(new Job(5, 3, 15));

        List<Job> result = JobSequencing(jobs);
        System.out.println("Scheduled jobs for maximum profit:");
        for (Job job : result) {
            System.out.println("Job Id: " + job.Id + ", Deadline: " + job.Deadline + ", Profit: " + job.Profit);
        }
    }
}

------------------------------------------------------------------------------------------------------------------------------
implementation:

import java.util.Arrays;
 
class Job {
    char id;     // Job Id
    int deadline; // Deadline of job
    int profit;  // Profit if job is completed before or on deadline
    
    // Constructor
    public Job(char id, int deadline, int profit) {
        this.id = id;
        this.deadline = deadline;
        this.profit = profit;
    }
}
 
public class JobSequencing {
 
    // Function to schedule the jobs to maximize profit
    public static void scheduleJobs(Job[] jobs, int n) {
        // Sort jobs in descending order of profit
        Arrays.sort(jobs, (a, b) -> b.profit - a.profit);
        
        // To keep track of free time slots
        boolean[] result = new boolean[n];
        
        // To store the sequence of jobs
        char[] jobOrder = new char[n];
        
        // Initialize all slots to be free
        for (int i = 0; i < n; i++) {
            result[i] = false;
        }
        
        // Iterate through all given jobs
        for (int i = 0; i < jobs.length; i++) {
            // Find a free slot for this job (starting from the last possible slot)
            for (int j = Math.min(n, jobs[i].deadline) - 1; j >= 0; j--) {
                // Free slot found
                if (result[j] == false) {
                    result[j] = true;
                    jobOrder[j] = jobs[i].id;
                    break;
                }
            }
        }
        
        // Print the job order to maximize profit
        System.out.println("Job sequence to maximize profit:");
        for (int i = 0; i < n; i++) {
            if (result[i]) {
                System.out.print(jobOrder[i] + " ");
            }
        }
        System.out.println();
    }
 
    // Driver code
    public static void main(String[] args) {
        Job[] jobs = {
            new Job('a', 2, 100),
            new Job('b', 1, 19),
            new Job('c', 2, 27),
            new Job('d', 1, 25),
            new Job('e', 3, 15)
        };
        int n = 3;  // Number of time slots
        scheduleJobs(jobs, n);
    }
}
-----------------------------------------------------------------------------------------------------------------------------

public class Knapsack {
    
    public static int knapsack(int W, int[] weights, int[] values) {
        int n = weights.length;
        int[][] dp = new int[n + 1][W + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int w = 0; w <= W; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        
        return dp[n][W];
    }
    
    public static void main(String[] args) {
        int W = 50;
        int[] weights = {10, 20, 30};
        int[] values = {60, 100, 120};
        
        System.out.println(knapsack(W, weights, values));  // Output: 220
    }
}

.....................................................................................................................................................
Task 2: Longest Common Subsequence (LCS)

The Longest Common Subsequence problem can also be solved using dynamic programming. Here is the Java implementation for finding the length of the LCS:


public class LCS {
    
    public static int lcs(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        // Build the dp array in bottom-up manner
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    public static void main(String[] args) {
        String text1 = "abcde";
        String text2 = "ace";
        
        System.out.println(lcs(text1, text2));  // Output: 3
    }
}

-------------------------------------------------------------------------------------------------------------------------------

knapsackmycode:

import java.util.Arrays;
public class FractionalKnapsack {
	static int temp,temp1;
	
	
	public static int  fractionalKnapsack(int weight[],int values[], int maxWeight,int n)
	{
		
	      int low=0,high=values.length-1;
		
		   quickSort(values,low,high,weight);
		     
		   int compare=0,sum=0;
		   
		compare=0;
		   
		   for(int i=n;i>=0;i--)
		   {
			  //compare=compare+weight[i];
          
           if(compare<=maxWeight)
           {
        	   if(i!=n)
        	   {
        		   
        	   
        	   sum=sum+values[i];
        	  
                
           
        	   }
        	   if(i==n)
        		   
        	   {
        		   compare=compare+weight[n-1];
        	   }
        	   else {
        		   compare=compare+weight[i-1];
        	   }
        	  // compare=compare+weight[i];
           }
           
           else {
        	   if(i!=0)
        	   {
        	     
        	   compare=compare-weight[i];
        	   compare=compare+weight[i-1];
        	   
        	   }
        	   
        	 }
			   
		   
		   }
		     return sum;
	}
	
	public static void quickSort(int values[],int low,int high,int weight[])
	{
		
		if(low>=high)
		{
			return;
		}
		int mid=low+(high-low)/2;
		int pivot=values[mid];
		int i=low;
		int j=high;
		while(i<=j)
		{
			while(values[i]<pivot)
			{
				i++;
			}
			
			
			
			while(values[j]>pivot)
			{
				j--;
			}
			
	       if(i<=j)
	       {
	    	   temp=values[i];
	    	   temp1=weight[i];
	    	   values[i]=values[j];
	    	   weight[i]=weight[j];
	    	   values[j]=temp;
	    	   weight[j]=temp1;
	    	   
	    	   i++;
	    	   j--;
	    	   
	       }
	       
	       
	       
		}
		
		quickSort(values,low,j,weight);
		quickSort(values,i,high,weight);
		
}
	
	
	public static void main(String args[])
	
{
      int weight[]=	{1,4,2,6,5,8};
      int values[]= {400,254,978,121,542,70};
      int maxWeight=20;
      int n=weight.length;
      
       System.out.println("MaxValue of maxCapacity of knapsack: "+fractionalKnapsack(weight,values,maxWeight,n));
		
}
---------------------------------------------------------------------------------------------------
LCS implementation:

class LCS{
    

public static void lcs(String a , String compare)
{
    int i=0,j=0,count=0,x=0,k=0,h=0;
    int n=compare.length()-1,temp=0,ref=0;
   while(h<=compare.length()-1)
   {
    while(i<=n)
    {
        
        while(j<=a.length()-1)
        {
           
            
           if( compare.charAt(i)==a.charAt(j) )
           {
               
               count+=1;
               temp+=1;
                k=j;
               System.out.print(a.charAt(j));
           }
          
           if(temp>0)
           {
               j=a.length();
           }
           j++;
           
        }
        i++;
        j=k+1;
        temp=0;
    }
    System.out.print(" ");
      if(ref<count)
      {
          ref=count;
      }
      
    //System.out.print( "      " + "count:"+count);
   // System.out.println("\n");
    h++;
    i=h;
    j=0;
    count=0;
   }
   System.out.println("\n\n LCS count: "+ref);
    
    
}

    public static void main(String args[])
    {
        String a="abcdefghijklm";
        String compare="dacegfkmi";
        lcs(a,compare);
    }
    
    
}
	
}
---------------------------------------------------------------------------------------------------------------------------------------------------------

[12:23 PM] Maria (Unverified)
package com.commoncode;
 
class FirstClass{
	public  FirstClass()
	{super();
		System.out.println("1");
	}
}
class SecondClass extends FirstClass{
	public  SecondClass()
	{
		super();
		System.out.println("2");
	}
}
class ThirdClass extends SecondClass{
	public  ThirdClass()
	{
		System.out.println("3");
	}
}
public class Main {
 
	public static void main(String[] args) {
		ThirdClass t=new ThirdClass();
 
	}
 
}
 
[12:23 PM] Maria (Unverified)
aaaaa
[12:23 PM] Maria (Unverified)
package com.commoncode;
 
 
import java.util.Arrays;
 
public class NestedforLoopEx {
 
	public static void main(String[] args) {
		int[] array= new int[5];
		for(int j=5;j>0;j--)
		{			array[5-j]=j;
			}
			Arrays.fill(array,1,5,8);
			
			for(int j=0;j<5;j++)
			{
				System.out.print(array[j]);
		}
		
	}
 
}
[12:23 PM] Maria (Unverified)
bbbbb
[12:24 PM] Maria (Unverified)
package com.commoncode;
 
 
interface An{
	default void show() {
		System.out.println("A");
	}
}
interface Bn{
	default void show() {
		System.out.println("B");
	}
}
class C implements An,Bn{
 
	@Override
	public void show() {
		// TODO Auto-generated method stub
		An.super.show();
	}
	
}
 
public class Test2 {
 
	public static void main(String[] args) {
 
C c=new C();
c.show();
 
	}
 
}
 
[12:24 PM] Maria (Unverified)
cccc
[12:24 PM] Maria (Unverified)
package com.commoncode;
 
public class Test6 {
	public static void main(String[] args) {
		int x=-4;
		System.out.println(x>>1);
		int y=4;
		System.out.println(y>>1);;
 
	}
}
 
[12:24 PM] Maria (Unverified)
dddd
[12:24 PM] Maria (Unverified)
package com.commoncode;
 
 
class Base{
	static String s="Super class";
public	Base(){
		System.out.printf("1");
	}
}
 
public class Derived extends Base {
	public Derived() {
		super(); //1 2
		System.out.printf("2");
			
	}
	
	public static void main(String[] args) {
		Derived d=new Derived();
	}
}
[12:24 PM] Maria (Unverified)
eeee
[12:24 PM] Maria (Unverified)
package com.commoncode;
 
//private - default,protected,public
 
class A{
	int i;
	void display() {
		System.out.println(i);
	
	}
}
class B extends A{
	int j;
		void  display() {
		System.out.println(j);
	
	}
}
public class InheritanceDemo {
 
	public static void main(String[] args) {
	
B obj=new B();
obj.i=1;
obj.j=2;
obj.display();
	}
 
}

---------------------------------------------------------------------------------------------------------------------------------------------

public class KnightsTour {
    private static final int N = 8;

    private static boolean isSafe(int x, int y, int[][] board) {
        return (x >= 0 && x < N && y >= 0 && y < N && board[x][y] == -1);
    }

    private static boolean solveKnightsTour(int[][] board, int x, int y, int moveCount, int[] xMove, int[] yMove) {
        if (moveCount == N * N) {
            return true;
        }

        for (int i = 0; i < 8; i++) {
            int nextX = x + xMove[i];
            int nextY = y + yMove[i];
            if (isSafe(nextX, nextY, board)) {
                board[nextX][nextY] = moveCount;
                if (solveKnightsTour(board, nextX, nextY, moveCount + 1, xMove, yMove)) {
                    return true;
                } else {
                    board[nextX][nextY] = -1; // backtrack
                }
            }
        }

        return false;
    }

    public static void main(String[] args) {
        int[][] board = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                board[i][j] = -1; // Initialize all cells as unvisited
            }
        }

        int[] xMove = {2, 1, -1, -2, -2, -1, 1, 2};
        int[] yMove = {1, 2, 2, 1, -1, -2, -2, -1};

        int startX = 0, startY = 0; // Starting position of the knight
        board[startX][startY] = 0; // Mark the starting cell as visited

        if (solveKnightsTour(board, startX, startY, 1, xMove, yMove)) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(board[i][j] + " ");
                }
                System.out.println();
            }
        } else {
            System.out.println("No solution exists.");
        }
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------
    public class OptimalBinarySearchTree {
    public static void main(String[] args) {
        double[] keys = {10, 12, 20};
        double[] freq = {34, 8, 50};
        int n = keys.length;
        System.out.println("Cost of Optimal BST is " + optimalSearchTree(keys, freq, n));
    }

    private static double optimalSearchTree(double[] keys, double[] freq, int n) {
        double[][] cost = new double[n + 1][n + 1];

        for (int i = 0; i < n; i++) {
            cost[i][i] = freq[i];
        }

        for (int length = 2; length <= n; length++) {
            for (int i = 0; i <= n - length + 1; i++) {
                int j = i + length - 1;
                cost[i][j] = Double.MAX_VALUE;
                double sum = getSum(freq, i, j);

                for (int k = i; k <= j; k++) {
                    double temp = ((k > i) ? cost[i][k - 1] : 0) +
                                  ((k < j) ? cost[k + 1][j] : 0) + sum;
                    if (temp < cost[i][j]) {
                        cost[i][j] = temp;
                    }
                }
            }
        }
        return cost[0][n - 1];
    }

    private static double getSum(double[] freq, int i, int j) {
        double sum = 0;
        for (int k = i; k <= j; k++) {
            sum += freq[k];
        }
        return sum;
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------

public class OptimalBinarySearchTree {
    public static void main(String[] args) {
        double[] keys = {10, 12, 20};
        double[] freq = {34, 8, 50};
        int n = keys.length;
        System.out.println("Cost of Optimal BST is " + optimalSearchTree(keys, freq, n));
    }

    private static double optimalSearchTree(double[] keys, double[] freq, int n) {
        double[][] cost = new double[n][n];

        for (int i = 0; i < n; i++) {
            cost[i][i] = freq[i];
        }

        for (int length = 2; length <= n; length++) {
            for (int i = 0; i <= n - length; i++) {
                int j = i + length - 1;
                cost[i][j] = Double.MAX_VALUE;
                double sum = getSum(freq, i, j);

                for (int k = i; k <= j; k++) {
                    double temp = ((k > i) ? cost[i][k - 1] : 0) +
                                  ((k < j) ? cost[k + 1][j] : 0) + sum;
                    if (temp < cost[i][j]) {
                        cost[i][j] = temp;
                    }
                }
            }
        }
        return cost[0][n - 1];
    }

    private static double getSum(double[] freq, int i, int j) {
        double sum = 0;
        for (int k = i; k <= j; k++) {
            sum += freq[k];
        }
        return sum;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------
public class RatInMaze
{
    private static int[,] solution;

    public static bool SolveMaze(int[,] maze)
    {
        int n = maze.GetLength(0);
        solution = new int[n, n];

        if (SolveMazeUtil(maze, 0, 0))
        {
            PrintSolution(solution);
            return true;
        }

        Console.WriteLine("No solution found");
        return false;
    }

    private static bool SolveMazeUtil(int[,] maze, int x, int y)
    {
        int n = maze.GetLength(0);

        if (x == n - 1 && y == n - 1 && maze[x, y] == 1)
        {
            solution[x, y] = 1;
            return true;
        }

        if (IsSafe(maze, x, y))
        {
            solution[x, y] = 1;

            if (SolveMazeUtil(maze, x + 1, y))
                return true;

            if (SolveMazeUtil(maze, x, y + 1))
                return true;

            solution[x, y] = 0;
            return false;
        }

        return false;
    }

    private static bool IsSafe(int[,] maze, int x, int y)
    {
        int n = maze.GetLength(0);
        return (x >= 0 && x < n && y >= 0 && y < n && maze[x, y] == 1);
    }

    private static void PrintSolution(int[,] solution)
    {
        int n = solution.GetLength(0);
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                Console.Write(solution[i, j] + " ");
            }
            Console.WriteLine();
        }
    }
}

----------------------------------------------------------------------------------------------------------------------------------------

public class NQueenProblem {
    final int N = 8;

    boolean solveNQueen(int board[][], int col) {
        if (col >= N)
            return true;

        for (int i = 0; i < N; i++) {
            if (isSafe(board, i, col)) {
                board[i][col] = 1;

                if (solveNQueen(board, col + 1))
                    return true;

                board[i][col] = 0;
            }
        }

        return false;
    }

    boolean isSafe(int board[][], int row, int col) {
        int i, j;

        for (i = 0; i < col; i++)
            if (board[row][i] == 1)
                return false;

        for (i = row, j = col; i >= 0 && j >= 0; i--, j--)
            if (board[i][j] == 1)
                return false;

        for (i = row, j = col; j >= 0 && i < N; i++, j--)
            if (board[i][j] == 1)
                return false;

        return true;
    }

    void printSolution(int board[][]) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++)
                System.out.print(" " + board[i][j]
                                 + " ");
            System.out.println();
        }
    }

    public static void main(String args[]) {
        NQueenProblem Queen = new NQueenProblem();
        int board[][] = new int[Queen.N][Queen.N];
        if (!Queen.solveNQueen(board, 0)) {
            System.out.print("Solution does not exist");
            return;
        }

        Queen.printSolution(board);
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------


